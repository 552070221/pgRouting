BEGIN;
BEGIN
--q1
SELECT * FROM pgr_withPointsDD(
        'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
        'SELECT pid, edge_id, fraction, side from pointsOfInterest',
        3, 3.0);
NOTICE:  Calling process
NOTICE:  driving side:b
NOTICE:  freeing allocated memory not used anymore
NOTICE:  Starting processing
NOTICE:  Returning 9 tuples

NOTICE:  Returned message = original points
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
after sorting
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
after deleting repetitions
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
We have 6 different pointsafter deleting points with same id
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
point: 1	4	0.4	l	0
point: 2	5	0.4	l	0
point: 3	5	0.6	l	0
point: 4	4	0.6	r	0
point: 5	2	0.5	l	0
point: 6	1	1	l	0
working points: 6	1	1	l	0

pid6	eid1/t1	l
vertex_id of the point is the target2
Edge is one way or driving side is both or point side is both
Edge is one way: 0
driving side: b
point side: l
last edge: (id,source,target,cost,reverse_cost) = (1	2	2	1	-1)
last edge: (id,source,target,cost,reverse_cost) = (1	2	2	-1	1)
working points: 2	5	0.4	l	0
working points: 3	5	0.6	l	0

pid2	eid5/t0.4	l
vertex_id of the point is -1
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: b
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (5	3	-1	0.4	-1)

pid3	eid5/t0.6	l
vertex_id of the point is -2
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: b
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (5	-1	-2	0.2	-1)
last edge: (id,source,target,cost,reverse_cost) = (5	-2	6	0.4	-1)
last edge: (id,source,target,cost,reverse_cost) = (5	-2	6	-1	-1)
working points: 5	2	0.5	l	0

pid5	eid2/t0.5	l
vertex_id of the point is -3
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: b
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (2	2	-3	-1	0.5)
last edge: (id,source,target,cost,reverse_cost) = (2	-3	3	-1	-1)
last edge: (id,source,target,cost,reverse_cost) = (2	-3	3	-1	0.5)
working points: 1	4	0.4	l	0
working points: 4	4	0.6	r	0

pid1	eid4/t0.4	l
vertex_id of the point is -4
Edge is one way or driving side is both or point side is both
Edge is one way: 0
driving side: b
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (4	2	-4	0.4	-1)
new_edge: (id,source,target,cost,reverse_cost) = (4	2	-4	-1	0.4)

pid4	eid4/t0.6	r
vertex_id of the point is -5
Edge is one way or driving side is both or point side is both
Edge is one way: 0
driving side: b
point side: r
new_edge: (id,source,target,cost,reverse_cost) = (4	-4	-5	0.2	-1)
new_edge: (id,source,target,cost,reverse_cost) = (4	-4	-5	-1	0.2)
last edge: (id,source,target,cost,reverse_cost) = (4	-5	5	0.4	-1)
last edge: (id,source,target,cost,reverse_cost) = (4	-5	5	-1	0.4)
point: 6	1	1	l	2
point: 2	5	0.4	l	-1
point: 3	5	0.6	l	-2
point: 5	2	0.5	l	-3
point: 1	4	0.4	l	-4
point: 4	4	0.6	r	-5
Working with directed Graph
Path: -2 -> -2
seq	node	edge	cost	agg_cost
0	-2	-1	0	0
1	6	5	0.4	0.4
2	5	8	1	1.4
3	9	9	1	1.4
4	11	11	1	1.4
5	-5	4	0.4	1.8
6	-4	4	0.2	2
7	2	4	0.4	2.4
8	4	16	1	2.4
9	8	7	1	2.4
10	10	10	1	2.4
11	12	13	1	2.4
Path: -3 -> -3
seq	node	edge	cost	agg_cost
0	-3	-1	0	0
1	6	5	0.4	0.4
2	5	8	1	1.4
3	9	9	1	1.4
4	11	11	1	1.4
5	-4	4	0.4	1.8
6	-1	4	0.2	2
7	-6	4	0.4	2.4
8	4	16	1	2.4
9	8	7	1	2.4
10	10	10	1	2.4
11	12	13	1	2.4


 seq | node | edge | cost | agg_cost 
-----+------+------+------+----------
   1 |   -3 |   -1 |    0 |        0
   2 |    6 |    5 |  0.4 |      0.4
   3 |    5 |    8 |    1 |      1.4
   4 |    9 |    9 |    1 |      1.4
   5 |   11 |   11 |    1 |      1.4
   6 |    4 |   16 |    1 |      2.4
   7 |    8 |    7 |    1 |      2.4
   8 |   10 |   10 |    1 |      2.4
   9 |   12 |   13 |    1 |      2.4
(9 rows)

--q2
SELECT * FROM pgr_withPointsDD(
        'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
        'SELECT pid, edge_id, fraction, side from pointsOfInterest',
        3, 3.0,
        driving_side := 'r',
        details := true);
NOTICE:  Calling process
NOTICE:  driving side:r
NOTICE:  freeing allocated memory not used anymore
NOTICE:  Starting processing
NOTICE:  Returning 12 tuples

NOTICE:  Returned message = original points
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
after sorting
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
after deleting repetitions
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
We have 6 different pointsafter deleting points with same id
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
point: 1	4	0.4	l	0
point: 2	5	0.4	l	0
point: 3	5	0.6	l	0
point: 4	4	0.6	r	0
point: 5	2	0.5	l	0
point: 6	1	1	l	0
working points: 6	1	1	l	0

pid6	eid1/t1	l
vertex_id of the point is the target2
Edge is two way and driving side is different than the side of the point
last edge: (id,source,target,cost,reverse_cost) = (1	1	2	1	-1)
last edge: (id,source,target,cost,reverse_cost) = (1	2	2	-1	1)
working points: 2	5	0.4	l	0
working points: 3	5	0.6	l	0

pid2	eid5/t0.4	l
vertex_id of the point is -1
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: r
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (5	3	-1	0.4	-1)

pid3	eid5/t0.6	l
vertex_id of the point is -2
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: r
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (5	-1	-2	0.2	-1)
last edge: (id,source,target,cost,reverse_cost) = (5	-2	6	0.4	-1)
last edge: (id,source,target,cost,reverse_cost) = (5	-2	6	-1	-1)
working points: 5	2	0.5	l	0

pid5	eid2/t0.5	l
vertex_id of the point is -3
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: r
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (2	2	-3	-1	0.5)
last edge: (id,source,target,cost,reverse_cost) = (2	-3	3	-1	-1)
last edge: (id,source,target,cost,reverse_cost) = (2	-3	3	-1	0.5)
working points: 1	4	0.4	l	0
working points: 4	4	0.6	r	0

pid1	eid4/t0.4	l
vertex_id of the point is -4
Edge is two way and driving side is different than the side of the point
new_edge: (id,source,target,cost,reverse_cost) = (4	2	-4	-1	0.4)

pid4	eid4/t0.6	r
vertex_id of the point is -5
Edge is two way and driving side is the same as the side of the point
Breaking (source, target) edge only when its not the extreme of the segment
new_edge: (id,source,target,cost,reverse_cost) = (4	2	-5	0.6	-1)
last edge: (id,source,target,cost,reverse_cost) = (4	-5	5	0.4	-1)
last edge: (id,source,target,cost,reverse_cost) = (4	-4	5	-1	0.6)
point: 6	1	1	l	2
point: 2	5	0.4	l	-1
point: 3	5	0.6	l	-2
point: 5	2	0.5	l	-3
point: 1	4	0.4	l	-4
point: 4	4	0.6	r	-5
Working with directed Graph
Path: -2 -> -2
seq	node	edge	cost	agg_cost
0	-2	-1	0	0
1	6	5	0.4	0.4
2	5	8	1	1.4
3	9	9	1	1.4
4	11	11	1	1.4
5	-4	4	0.6	2
6	2	4	0.4	2.4
7	4	16	1	2.4
8	8	7	1	2.4
9	10	10	1	2.4
10	12	13	1	2.4
11	-5	4	0.6	3
Path: -3 -> -3
seq	node	edge	cost	agg_cost
0	-3	-1	0	0
1	6	5	0.4	0.4
2	5	8	1	1.4
3	9	9	1	1.4
4	11	11	1	1.4
5	-1	4	0.6	2
6	-6	4	0.4	2.4
7	4	16	1	2.4
8	8	7	1	2.4
9	10	10	1	2.4
10	12	13	1	2.4
11	-4	4	0.6	3


 seq | node | edge | cost | agg_cost 
-----+------+------+------+----------
   1 |   -3 |   -1 |    0 |        0
   2 |    6 |    5 |  0.4 |      0.4
   3 |    5 |    8 |    1 |      1.4
   4 |    9 |    9 |    1 |      1.4
   5 |   11 |   11 |    1 |      1.4
   6 |   -1 |    4 |  0.6 |        2
   7 |   -6 |    4 |  0.4 |      2.4
   8 |    4 |   16 |    1 |      2.4
   9 |    8 |    7 |    1 |      2.4
  10 |   10 |   10 |    1 |      2.4
  11 |   12 |   13 |    1 |      2.4
  12 |   -4 |    4 |  0.6 |        3
(12 rows)

--q3
SELECT * FROM pgr_withPointsDD(
        'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
        'SELECT pid, edge_id, fraction, side from pointsOfInterest',
        3, 3.0,
        driving_side := 'l',
        details := true);
NOTICE:  Calling process
NOTICE:  driving side:l
NOTICE:  freeing allocated memory not used anymore
NOTICE:  Starting processing
NOTICE:  Returning 12 tuples

NOTICE:  Returned message = original points
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
after sorting
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
after deleting repetitions
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
We have 6 different pointsafter deleting points with same id
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
point: 1	4	0.4	l	0
point: 2	5	0.4	l	0
point: 3	5	0.6	l	0
point: 4	4	0.6	r	0
point: 5	2	0.5	l	0
point: 6	1	1	l	0
working points: 6	1	1	l	0

pid6	eid1/t1	l
vertex_id of the point is the target2
Edge is two way and driving side is the same as the side of the point
Breaking (source, target) edge only when its not the extreme of the segment
last edge: (id,source,target,cost,reverse_cost) = (1	2	2	1	-1)
last edge: (id,source,target,cost,reverse_cost) = (1	1	2	-1	1)
working points: 2	5	0.4	l	0
working points: 3	5	0.6	l	0

pid2	eid5/t0.4	l
vertex_id of the point is -1
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: l
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (5	3	-1	0.4	-1)

pid3	eid5/t0.6	l
vertex_id of the point is -2
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: l
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (5	-1	-2	0.2	-1)
last edge: (id,source,target,cost,reverse_cost) = (5	-2	6	0.4	-1)
last edge: (id,source,target,cost,reverse_cost) = (5	-2	6	-1	-1)
working points: 5	2	0.5	l	0

pid5	eid2/t0.5	l
vertex_id of the point is -3
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: l
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (2	2	-3	-1	0.5)
last edge: (id,source,target,cost,reverse_cost) = (2	-3	3	-1	-1)
last edge: (id,source,target,cost,reverse_cost) = (2	-3	3	-1	0.5)
working points: 1	4	0.4	l	0
working points: 4	4	0.6	r	0

pid1	eid4/t0.4	l
vertex_id of the point is -4
Edge is two way and driving side is the same as the side of the point
Breaking (source, target) edge only when its not the extreme of the segment
new_edge: (id,source,target,cost,reverse_cost) = (4	2	-4	0.4	-1)

pid4	eid4/t0.6	r
vertex_id of the point is -5
Edge is two way and driving side is different than the side of the point
new_edge: (id,source,target,cost,reverse_cost) = (4	2	-5	-1	0.6)
last edge: (id,source,target,cost,reverse_cost) = (4	-4	5	0.6	-1)
last edge: (id,source,target,cost,reverse_cost) = (4	-5	5	-1	0.4)
point: 6	1	1	l	2
point: 2	5	0.4	l	-1
point: 3	5	0.6	l	-2
point: 5	2	0.5	l	-3
point: 1	4	0.4	l	-4
point: 4	4	0.6	r	-5
Working with directed Graph
Path: -2 -> -2
seq	node	edge	cost	agg_cost
0	-2	-1	0	0
1	6	5	0.4	0.4
2	5	8	1	1.4
3	9	9	1	1.4
4	11	11	1	1.4
5	-5	4	0.4	1.8
6	2	4	0.6	2.4
7	4	16	1	2.4
8	8	7	1	2.4
9	10	10	1	2.4
10	12	13	1	2.4
11	-4	4	0.4	2.8
Path: -3 -> -3
seq	node	edge	cost	agg_cost
0	-3	-1	0	0
1	6	5	0.4	0.4
2	5	8	1	1.4
3	9	9	1	1.4
4	11	11	1	1.4
5	-4	4	0.4	1.8
6	-6	4	0.6	2.4
7	4	16	1	2.4
8	8	7	1	2.4
9	10	10	1	2.4
10	12	13	1	2.4
11	-1	4	0.4	2.8


 seq | node | edge | cost | agg_cost 
-----+------+------+------+----------
   1 |   -3 |   -1 |    0 |        0
   2 |    6 |    5 |  0.4 |      0.4
   3 |    5 |    8 |    1 |      1.4
   4 |    9 |    9 |    1 |      1.4
   5 |   11 |   11 |    1 |      1.4
   6 |   -4 |    4 |  0.4 |      1.8
   7 |   -6 |    4 |  0.6 |      2.4
   8 |    4 |   16 |    1 |      2.4
   9 |    8 |    7 |    1 |      2.4
  10 |   10 |   10 |    1 |      2.4
  11 |   12 |   13 |    1 |      2.4
  12 |   -1 |    4 |  0.4 |      2.8
(12 rows)

--q4
SELECT * FROM pgr_withPointsDD(
        'SELECT id, source, target, cost, reverse_cost FROM edge_table ORDER BY id',
        'SELECT pid, edge_id, fraction, side from pointsOfInterest',
        3, 3.0,
        driving_side := 'b',
        details := true);
NOTICE:  Calling process
NOTICE:  driving side:b
NOTICE:  freeing allocated memory not used anymore
NOTICE:  Starting processing
NOTICE:  Returning 12 tuples

NOTICE:  Returned message = original points
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
after sorting
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
after deleting repetitions
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
We have 6 different pointsafter deleting points with same id
1	4	0.4	l
2	5	0.4	l
3	5	0.6	l
4	4	0.6	r
5	2	0.5	l
6	1	1	l
point: 1	4	0.4	l	0
point: 2	5	0.4	l	0
point: 3	5	0.6	l	0
point: 4	4	0.6	r	0
point: 5	2	0.5	l	0
point: 6	1	1	l	0
working points: 6	1	1	l	0

pid6	eid1/t1	l
vertex_id of the point is the target2
Edge is one way or driving side is both or point side is both
Edge is one way: 0
driving side: b
point side: l
last edge: (id,source,target,cost,reverse_cost) = (1	2	2	1	-1)
last edge: (id,source,target,cost,reverse_cost) = (1	2	2	-1	1)
working points: 2	5	0.4	l	0
working points: 3	5	0.6	l	0

pid2	eid5/t0.4	l
vertex_id of the point is -1
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: b
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (5	3	-1	0.4	-1)

pid3	eid5/t0.6	l
vertex_id of the point is -2
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: b
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (5	-1	-2	0.2	-1)
last edge: (id,source,target,cost,reverse_cost) = (5	-2	6	0.4	-1)
last edge: (id,source,target,cost,reverse_cost) = (5	-2	6	-1	-1)
working points: 5	2	0.5	l	0

pid5	eid2/t0.5	l
vertex_id of the point is -3
Edge is one way or driving side is both or point side is both
Edge is one way: 1
driving side: b
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (2	2	-3	-1	0.5)
last edge: (id,source,target,cost,reverse_cost) = (2	-3	3	-1	-1)
last edge: (id,source,target,cost,reverse_cost) = (2	-3	3	-1	0.5)
working points: 1	4	0.4	l	0
working points: 4	4	0.6	r	0

pid1	eid4/t0.4	l
vertex_id of the point is -4
Edge is one way or driving side is both or point side is both
Edge is one way: 0
driving side: b
point side: l
new_edge: (id,source,target,cost,reverse_cost) = (4	2	-4	0.4	-1)
new_edge: (id,source,target,cost,reverse_cost) = (4	2	-4	-1	0.4)

pid4	eid4/t0.6	r
vertex_id of the point is -5
Edge is one way or driving side is both or point side is both
Edge is one way: 0
driving side: b
point side: r
new_edge: (id,source,target,cost,reverse_cost) = (4	-4	-5	0.2	-1)
new_edge: (id,source,target,cost,reverse_cost) = (4	-4	-5	-1	0.2)
last edge: (id,source,target,cost,reverse_cost) = (4	-5	5	0.4	-1)
last edge: (id,source,target,cost,reverse_cost) = (4	-5	5	-1	0.4)
point: 6	1	1	l	2
point: 2	5	0.4	l	-1
point: 3	5	0.6	l	-2
point: 5	2	0.5	l	-3
point: 1	4	0.4	l	-4
point: 4	4	0.6	r	-5
Working with directed Graph
Path: -2 -> -2
seq	node	edge	cost	agg_cost
0	-2	-1	0	0
1	6	5	0.4	0.4
2	5	8	1	1.4
3	9	9	1	1.4
4	11	11	1	1.4
5	-5	4	0.4	1.8
6	-4	4	0.2	2
7	2	4	0.4	2.4
8	4	16	1	2.4
9	8	7	1	2.4
10	10	10	1	2.4
11	12	13	1	2.4
Path: -3 -> -3
seq	node	edge	cost	agg_cost
0	-3	-1	0	0
1	6	5	0.4	0.4
2	5	8	1	1.4
3	9	9	1	1.4
4	11	11	1	1.4
5	-4	4	0.4	1.8
6	-1	4	0.2	2
7	-6	4	0.4	2.4
8	4	16	1	2.4
9	8	7	1	2.4
10	10	10	1	2.4
11	12	13	1	2.4


 seq | node | edge | cost | agg_cost 
-----+------+------+------+----------
   1 |   -3 |   -1 |    0 |        0
   2 |    6 |    5 |  0.4 |      0.4
   3 |    5 |    8 |    1 |      1.4
   4 |    9 |    9 |    1 |      1.4
   5 |   11 |   11 |    1 |      1.4
   6 |   -4 |    4 |  0.4 |      1.8
   7 |   -1 |    4 |  0.2 |        2
   8 |   -6 |    4 |  0.4 |      2.4
   9 |    4 |   16 |    1 |      2.4
  10 |    8 |    7 |    1 |      2.4
  11 |   10 |   10 |    1 |      2.4
  12 |   12 |   13 |    1 |      2.4
(12 rows)

--q5
ROLLBACK;
ROLLBACK
