#!/usr/bin/perl -w
eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
    if 0; #$running_under_some_shell

use strict;
use Data::Dumper;
use Cwd qw(cwd chdir);

my $DEBUG = 0;

sub Usage {
    die "Usage: mk-signature-file <version>\n";
}

my $version = shift @ARGV || Usage();

my $sql = "lib/pgrouting--$version.sql";
my $sig = "lib/pgrouting--$version.sig";

die "ERROR: File '$sql' does not exist!\n"
    unless -f $sql;

my ($types, $funcs) = parse_signatures( $sql );

open(SIG, ">$sig") || die "ERROR: Failed to create '$sig' : $!\n";
print SIG "#VERSION pgrouting $version\n";
print SIG "#TYPES\n";
print SIG join("\n", @{$types}), "\n";
print SIG "#FUNCTIONS\n";
print SIG join("\n", @{$funcs}), "\n";
close(SIG);

exit 0;


sub parse_signatures {
    my $file = shift;

    # now read and parse it
    my %sigs = ();
    open(IN, $file) || die "ERROR: '$file' does not exist!\n";
    my @data = <IN>;
    close(IN);
    my $data = join('', @data);
    # delete C style comments
    $data =~ s{
        /\*
        .*?
        \*/
    } []gsx;
    # delete sql comments
    $data =~ s/--[^\n]*\n//gs;

    # TODO extract TYPEs
    my @types = $data =~ /create\s+type\s+(\w+\s+as\s*\([^\)]+\))/igs;
    @types = sort @types;
    for (my $i=0; $i<@types; $i++) {
        $types[$i] =~ s/\bas\s*\(/\(/is;
        $types[$i] =~ s/\s+/ /gs;
        $types[$i] =~ s/\s*([,\(\)])\s*/$1/gs;
        $types[$i] =~ s/\b(\w+)\s([^,\)]+)([,\)])/$2$3/gs;
    }

    # extract functions
    my @funcs = $data =~ /create\s+or\s+replace\s+function\s+(\w+\s*\([^\)]+\))\s*RETURNS/igs;
    @funcs = sort @funcs;
    # clean up functions
    for (my $i=0; $i<@funcs; $i++) {
        $funcs[$i] =~ s/\s+/ /gs;
        $funcs[$i] =~ s/\sdefault\s*((?:\()[^\)]+\)|[^\(\),]+)//ig;
        $funcs[$i] =~ s/(IN|OUT)\s(\w+)\s([^,\)]+)/$1 $3/ig;
        $funcs[$i] =~ s/\(\s+/(/g;
        $funcs[$i] =~ s/,\s+/,/g;
        $funcs[$i] = parse_function_args($funcs[$i]);
    }

    print Data::Dumper->Dump([\@types, \@funcs], ['types', 'funcs']) if $DEBUG;

    return (\@types, \@funcs);
}


sub parse_function_args {
    my $str = shift;
    $str = lc($str);
    my @parts = split /,/, $str;
    foreach my $p (@parts) {
        next if  $p =~ /\b(in|out)\s(\w+)/;
        $p =~ s/\b(\w+)\s(\w+)/$2/;
    }
    return join(',', @parts);
}

