#!/usr/bin/perl -w
eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
    if 0; #$running_under_some_shell

use strict;
use Data::Dumper;
use Cwd qw(cwd chdir);
use File::Find ();

my $DEBUG = 0;

use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;


# Algorithm
# 1. check if lib/pgrouting--<version>.sig exists and load it
# 2. get a list of version signatures from tools/sigs/*
# 3. foreach old version sig file
# 4.   generate an update file in lib/

sub Usage {
    die "Usage: build-extension-update-files <version>\n";
}

my $version = shift @ARGV || Usage();

my $SIG = "lib/pgrouting--$version.sig";
my $SQL = "lib/pgrouting--$version.sql";
die "ERROR: Failed to find '$SIG'\n" unless -f $SIG;
die "ERROR: Failed to find '$SQL'\n" unless -f $SQL;

my @old_files = ();
my $new_hash = read_sig_file( "lib/pgrouting--$version.sig" );

File::Find::find({wanted => \&wanted}, '../tools/sigs/');

for my $old_file ( sort @old_files ) {
    my $old_hash = read_sig_file( $old_file );
    generate_upgrade_script( $new_hash, $old_hash);
}

exit 0;


sub wanted {
    /^.*\.sig\z/s &&
    push @old_files, $name;
}


sub read_sig_file {
    my $file = shift;

    my %hash = ();

    open(IN, $file) || die "ERROR: Failed to open '$file'\n";

    my $state = 0;
    while (my $line = <IN>) {
        if ($line =~ /^#VERSION pgrouting (\d+\.\d+\.\d+)\s*$/i) {
            $hash{VERSION} = $1;
        }
        elsif ($line =~ /^#TYPES\s*/i) {
            $state = 1;
            next;
        }
        elsif ($line =~ /^#FUNCTIONS\s*/i) {
            $state = 2;
            next;
        }
        elsif ($line =~ /^#/) {
            next;
        }
        $line =~ s/\s*$//;
        if ($state == 1) {
            push @{$hash{types}}, $line;
        }
        elsif ($state == 2) {
            push @{$hash{funcs}}, $line;
        }
    }
    close(IN);

    return \%hash;
}

sub generate_upgrade_script {
    my ($new, $old) = @_;

    my $err = 0;
    my @types2remove = ();
    my @commands = ();

    my $n_ver = $new->{VERSION};
    my $o_ver = $old->{VERSION};

    # analyze types

    my $ntype = $new->{types};
    my $otype = $old->{types};

    # create a hash like <name> => <column_list> for new types
    my %ntype_h = ();
    for my $x (@{$ntype}) {
        $x =~ m/(\w+)(\([^\)]+\))$/;
        $ntype_h{lc($1)} = lc($2);
    }

    # check if old type exists with different column types
    for my $x (@{$otype}) {
        $x =~ m/(\w+)(\([^\)]+\))$/;
        my $name = lc($1);
        my $cols = lc($2);
        if ($ntype_h{$name}) {
            if ($ntype_h{$name} ne $cols) {
                warn "WARNING: old type '$name$cols' changed to '$name$ntype_h{$name}' !\n";
                $err = 1;
            }
            else {
                push @types2remove, $name;
            }
        }
    }


    # analyze function sigs

    my $nsig = $new->{funcs};
    my $osig = $old->{funcs};
    my %fmap = map { $_ => 1 } @{$nsig};

    for my $x (@{$osig}) {
        my $exists = $fmap{$x} || '0';
        print "$exists\t$x\n" if $DEBUG;
        if (! $exists) {
            print "ALTER EXTENSION pgrouting DROP FUNCTION $x;\n" if $DEBUG;
            push @commands, "ALTER EXTENSION pgrouting DROP FUNCTION $x;\n";
        }
        print "DROP FUNCTION IF EXISTS $x;\n" if $DEBUG;
        push @commands, "DROP FUNCTION IF EXISTS $x;\n";
    }

    die "ERROR: pgrouting TYPE changed! Cannot continue!\n" if $err;

    write_script($o_ver, $n_ver, \@types2remove, join('', @commands));
}


sub write_script {
    my ($o_ver, $n_ver, $types, $cmds) = @_;

    open(OUT, ">lib/pgrouting--$o_ver--$n_ver.sql")
        || die "ERROR: failed to create 'lib/pgrouting-pgrouting--$o_ver--$n_ver.sql' : $!\n";
    print OUT <<EOF;
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-- pgRouting extension upgrade from $o_ver to $n_ver
-- generated by tools/build-extension-update-files
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-- remove functions no longer in the $n_ver extension
$cmds

-- now install the new extension

EOF

    open(IN, $SQL) ||
        die "ERROR: Failed to find '$SQL' : $!\n";
    my @file = <IN>;
    close(IN);

    remove_types( \@file, $types );

    print OUT @file;
    close(OUT);
}


sub remove_types {
    my ($data, $types) = @_;

    for my $type (@{$types}) {
        my $state = 1;
        for my $x (@{$data}) {
            if ($state == 1) {
                next unless $x =~ m/create\s+type\s+$type\b/i;
                $x = "-- $x";
                $state = 2
                    unless $x =~ m/create\s+type\s+$type\s+as\s*\([^\)]+\)/i;
            }
            elsif ($state == 2) {
                $x = "-- $x";
                last if $x =~ /\)\s*;/;
            }
        }
    }
}

