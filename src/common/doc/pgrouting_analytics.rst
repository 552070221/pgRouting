=========================
pgRouting Graph Analytics
=========================
:Author: Stephen Woodbridge <woodbri@swoodbridge.com>
:Date: $Date: 2013-03-22 20:14:00 -5000 (Fri, 22 Mar 2013) $
:Revision: $Revision: 0000 $
:Description: This is a collection of tools for analyzing graphs. It has been contributed to pgRouting by iMaptools.com.
:Copyright: Stephen Woodbridge. This is released under the MIT-X license.

It is common to find problems with graphs that have not been constructed
fully noded or in graphs with zlevels at intersection that have been 
entered incorrectly. An other problem is oneway streets that have been
entered in the wrong direction. We can not detect errors with respect 
to "ground" truth, but we can look for inconsistencies and some 
anomalies in a graph and report them for additional inspections.

We do not current have any visualization tools for these problems, but
I have used mapserver to render the graph and highlight potential 
problem areas. Someone familar with graphviz might contribute tools
for generating images with that.


Analyze a Graph
===============

.. function:: pgr_analyze_graph(edge_tab, geom_col, tol)
   :module: pgrouting_analytics.sql

   Analyzes the "edge_tab" and "vertices_tmp" tables and flags if
   nodes are deadends, ie vertices_tmp.cnt=1 and identifies nodes
   that might be disconnected because of gaps < tol or because of
   zlevel errors in the data. For example:

.. code-block:: sql

           select pgr_analyze_graph('mytab', 'the_geom', 0.000002);

       After the analyzing the graph, deadends are indentified by *cnt=1*
       in the "vertices_tmp" table and potential problems are identified
       with *chk=1*.

.. code-block:: sql

           select * from vertices_tmp where chk = 1;


Analyze One Way Streets
=======================

.. function:: pgr_analyze_oneway(tab, col, s_in_rules, s_out_rules, t_in_rules, t_out_rules)
   :module: pgrouting_analytics.sql

   This function analyzes oneway streets in a graph and identifies any
   flipped segments. Basically if you count the edges coming into a node
   and the edges exiting a node the number has to be greater than one.

   * tab              - edge table name (TEXT)
   * col              - oneway column name (TEXT)
   * s_in_rules       - source node in rules
   * s_out_rules      - source node out rules
   * t_in_tules       - target node in rules
   * t_out_rules      - target node out rules
   * two_way_if_null  - flag to treat oneway nNULL values as by directional

   After running this on a graph you can identify nodes with potential
   problems with the following query.

.. code-block:: sql

       select * from vertices_tmp where in=0 or out=0;

   The rules are defined as an array of text strings that if match the "col"
   value would be counted as true for the source or target in or out condition.

   Example
   =======

   Lets assume we have a table "st" of edges and a column "one_way" that
   might have values like:

   * 'FT'    - oneway from the source to the target node.
   * 'TF'    - oneway from the target to the source node.
   * 'B'     - two way street.
   * ''      - empty field, assume teoway.
   * <NULL>  - NULL field, use two_way_if_null flag.

   Then we could form the following query to analyze the oneway streets for
   errors.

.. code-block:: sql

   select pgr_analyze_oneway('st', 'one_way',
        ARRAY['', 'B', 'TF'],
        ARRAY['', 'B', 'FT'],
        ARRAY['', 'B', 'FT'],
        ARRAY['', 'B', 'TF'],
        true);

   -- now we can see the problem nodes
   select * from vertices_tmp where ein-0 or eout=0;

   -- and the problem edges connected to those nodes
   select gid
     from st a, vertices_tmp b
    where a.source=b.id and ein-0 or eout=0
   union
   select gid
     from st a, vertices_tmp b
    where a.target=b.id and ein-0 or eout=0;

Typically these problems are generated by a break in the network, the
oneway direction set wrong, maybe an error releted to zlevels or
a network that is not properly noded.




Utility functions
=================

    .. function:: pgr_is_column_in_table(tab, col)
       :module: pgrouting_analytics.sql

       Return true ot false if column "col" exists in table "tab"

    .. function:: pgr_is_column_indexed(tab, col)
       :module: pgrouting_analytics.sql

       Return true ot false if column "col" in table "tab" is indexed.


