<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pgRouting Concepts &mdash; pgRouting Manual (2.4)</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'v2.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="pgRouting Manual (2.4)" href="index.html" />
    <link rel="next" title="pgr_version" href="pgr_version.html" />
    <link rel="prev" title="Sample Data" href="sampledata.html" /> 
  </head>
  <body>
      <div class="header"><img class="rightlogo" src="_static/pgrouting.png" alt="Logo"/><h1 class="heading"><a href="index.html">
          <span>pgRouting Manual (2.4)</span></a></h1>
        <h2 class="heading"><span>pgRouting Concepts</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="sampledata.html">Sample Data</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="pgr_version.html">pgr_version</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="pgrouting-concepts">
<span id="id1"></span><h1>pgRouting Concepts<a class="headerlink" href="#pgrouting-concepts" title="Permalink to this headline">¶</a></h1>
<p class="rubric">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#getting-started"><em>Getting Started</em></a><ul>
<li><a class="reference internal" href="#create-database"><em>Create a routing Database</em></a></li>
<li><a class="reference internal" href="#load-data"><em>Load Data</em></a></li>
<li><a class="reference internal" href="#build-topology"><em>Build a Routing Topology</em></a></li>
<li><a class="reference internal" href="#check-graph"><em>Check the Routing Topology</em></a></li>
<li><a class="reference internal" href="#compute-path"><em>Compute a Path</em></a></li>
<li><a class="reference external" href="http://workshop.pgrouting.org">pgRouting Workshop</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inner-queries"><em>Inner Queries</em></a></li>
<li><a class="reference internal" href="#return-values"><em>Return columns &amp; values</em></a></li>
<li><a class="reference internal" href="#advanced-topics"><em>Advanced Topics</em></a><ul>
<li><a class="reference internal" href="#topology"><em>Routing Topology</em></a></li>
<li><a class="reference internal" href="#analytics"><em>Graph Analytics</em></a></li>
<li><a class="reference internal" href="#performance"><em>Performance Tips</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-contribute"><em>How to contribute</em></a></li>
</ul>
<div class="section" id="getting-started">
<span id="id2"></span><h2>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>This is a simple guide to walk you through the steps of getting started
with pgRouting. In this guide we will cover:</p>
<ul class="simple">
<li><a class="reference internal" href="#create-database"><em>Create a routing Database</em></a></li>
<li><a class="reference internal" href="#load-data"><em>Load Data</em></a></li>
<li><a class="reference internal" href="#build-topology"><em>Build a Routing Topology</em></a></li>
<li><a class="reference internal" href="#check-graph"><em>Check the Routing Topology</em></a></li>
</ul>
<div class="section" id="create-a-routing-database">
<span id="create-database"></span><h3>Create a routing Database<a class="headerlink" href="#create-a-routing-database" title="Permalink to this headline">¶</a></h3>
<p>The first thing we need to do is create a database and load pgrouting in
the database. Typically you will create a database for each project. Once
you have a database to work in, your can load your data and build your
application in that database. This makes it easy to move your project
later if you want to to say a production server.</p>
<p>For Postgresql 9.2 and later versions</p>
<div class="highlight-bash"><div class="highlight"><pre>createdb mydatabase
psql mydatabase -c <span class="s2">&quot;create extension postgis&quot;</span>
psql mydatabase -c <span class="s2">&quot;create extension pgrouting&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="load-data">
<span id="id3"></span><h3>Load Data<a class="headerlink" href="#load-data" title="Permalink to this headline">¶</a></h3>
<p>How you load your data will depend in what form it comes it. There are
various OpenSource tools that can help you, like:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">osm2pgrouting:</th><td class="field-body"><ul class="first simple">
<li>this is a tool for loading OSM data into postgresql with pgRouting requirements</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">shp2pgsql:</th><td class="field-body"><ul class="first simple">
<li>this is the postgresql shapefile loader</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">ogr2ogr:</th><td class="field-body"><ul class="first simple">
<li>this is a vector data conversion utility</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">osm2pgsql:</th><td class="field-body"><ul class="first last simple">
<li>this is a tool for loading OSM data into postgresql</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>So these tools and probably others will allow you to read vector data so that
you may then load that data into your database as a table of some kind. At this
point you need to know a little about your data structure and content. One easy
way to browse your new data table is with pgAdmin3 or phpPgAdmin.</p>
</div>
<div class="section" id="build-a-routing-topology">
<span id="build-topology"></span><h3>Build a Routing Topology<a class="headerlink" href="#build-a-routing-topology" title="Permalink to this headline">¶</a></h3>
<p>Next we need to build a topology for our street data. What this means is that
for any given edge in your street data the ends of that edge will be connected
to a unique node and to other edges that are also connected to that same unique
node. Once all the edges are connected to nodes we have a graph that can be
used for routing with pgrouting. We provide a tool that will help with this:</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this step is not needed if data is loaded with <cite>osm2pgrouting</cite></p>
</div>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">pgr_createTopology</span><span class="p">(</span><span class="s1">&#39;myroads&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">000001</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><a class="reference internal" href="pgr_createTopology.html#pgr-create-topology"><em>pgr_createTopology</em></a></li>
</ul>
</div>
<div class="section" id="check-the-routing-topology">
<span id="check-graph"></span><h3>Check the Routing Topology<a class="headerlink" href="#check-the-routing-topology" title="Permalink to this headline">¶</a></h3>
<p>There are lots of possible sources for errors in a graph. The data that you
started with may not have been designed with routing in mind. A graph has some
very specific requirements. One is that it is <em>NODED</em>, this means that except
for some very specific use cases, each road segment starts and ends at a node
and that in general is does not cross another road segment that it should be
connected to.</p>
<p>There can be other errors like the direction of a one-way street being entered
in the wrong direction. We do not have tools to search for all possible errors
but we have some basic tools that might help.</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">select</span> <span class="n">pgr_analyzegraph</span><span class="p">(</span><span class="s1">&#39;myroads&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">000001</span><span class="p">);</span>
<span class="k">select</span> <span class="n">pgr_analyzeoneway</span><span class="p">(</span><span class="s1">&#39;myroads&#39;</span><span class="p">,</span>  <span class="n">s_in_rules</span><span class="p">,</span> <span class="n">s_out_rules</span><span class="p">,</span>
                                     <span class="n">t_in_rules</span><span class="p">,</span> <span class="n">t_out_rules</span>
                                     <span class="n">direction</span><span class="p">)</span>
<span class="k">select</span> <span class="n">pgr_nodeNetwork</span><span class="p">(</span><span class="s1">&#39;myroads&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">001</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><a class="reference internal" href="pgr_analyzeGraph.html#pgr-analyze-graph"><em>pgr_analyzeGraph</em></a></li>
<li><a class="reference internal" href="pgr_analyzeOneWay.html#pgr-analyze-oneway"><em>pgr_analyzeOneway</em></a></li>
<li><a class="reference internal" href="pgr_nodeNetwork.html#pgr-node-network"><em>pgr_nodeNetwork</em></a></li>
</ul>
</div>
<div class="section" id="compute-a-path">
<span id="compute-path"></span><h3>Compute a Path<a class="headerlink" href="#compute-a-path" title="Permalink to this headline">¶</a></h3>
<p>Once you have all the preparation work done above, computing a route is fairly easy.
We have a lot of different algorithms that can work with your prepared road
network. The general form of a route query is:</p>
<div class="highlight-sql"><div class="highlight"><pre>select pgr_dijkstra(`SELECT * FROM myroads&#39;, 1, 2)
</pre></div>
</div>
<p>As you can see this is fairly straight forward and you can look and the
specific algorithms for the details of the signatures and how to use them.
These results have information like edge id and/or the
node id along with the cost or geometry for the step in the path from <em>start</em>
to <em>end</em>. Using the ids you can join these result back to your edge table
to get more information about each step in the path.</p>
<ul class="simple">
<li><a class="reference internal" href="pgr_dijkstra.html#pgr-dijkstra"><em>pgr_dijkstra</em></a></li>
</ul>
</div>
</div>
<div class="section" id="inner-queries">
<span id="id4"></span><h2>Inner Queries<a class="headerlink" href="#inner-queries" title="Permalink to this headline">¶</a></h2>
<p>There are several kinds of valid inner queries and also the columns returned are depending of the function..
Which kind of <strong>edges_sql</strong> will depend on the function(s) requirements.</p>
<div class="section" id="description-of-the-edges-sql-query-for-dijkstra-like-functions">
<h3>Description of the edges_sql query for dijkstra like functions<a class="headerlink" href="#description-of-the-edges-sql-query-for-dijkstra-like-functions" title="Permalink to this headline">¶</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">edges_sql:</th><td class="field-body">an SQL query, which should return a set of rows with the following columns:</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="14%" />
<col width="6%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>id</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td>Identifier of the edge.</td>
</tr>
<tr class="row-odd"><td><strong>source</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td>Identifier of the first end point vertex of the edge.</td>
</tr>
<tr class="row-even"><td><strong>target</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td>Identifier of the second end point vertex of the edge.</td>
</tr>
<tr class="row-odd"><td><strong>cost</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-NUMERICAL</span></tt></td>
<td>&nbsp;</td>
<td><p class="first">Weight of the edge  <cite>(source, target)</cite></p>
<ul class="last simple">
<li>When negative: edge <cite>(source, target)</cite> does not exist, therefore it&#8217;s not part of the graph.</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><strong>reverse_cost</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-NUMERICAL</span></tt></td>
<td>-1</td>
<td><p class="first">Weight of the edge <cite>(target, source)</cite>,</p>
<ul class="last simple">
<li>When negative: edge <cite>(target, source)</cite> does not exist, therefore it&#8217;s not part of the graph.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Where:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">ANY-INTEGER:</th><td class="field-body">SMALLINT, INTEGER, BIGINT</td>
</tr>
<tr class="field-even field"><th class="field-name">ANY-NUMERICAL:</th><td class="field-body">SMALLINT, INTEGER, BIGINT, REAL, FLOAT</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="description-of-the-edges-sql-query-id-is-not-necessary">
<h3>Description of the edges_sql query (id is not necessary)<a class="headerlink" href="#description-of-the-edges-sql-query-id-is-not-necessary" title="Permalink to this headline">¶</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">edges_sql:</th><td class="field-body">an SQL query, which should return a set of rows with the following columns:</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="14%" />
<col width="6%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>source</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td>Identifier of the first end point vertex of the edge.</td>
</tr>
<tr class="row-odd"><td><strong>target</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td>Identifier of the second end point vertex of the edge.</td>
</tr>
<tr class="row-even"><td><strong>cost</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-NUMERICAL</span></tt></td>
<td>&nbsp;</td>
<td><p class="first">Weight of the edge  <cite>(source, target)</cite></p>
<ul class="last simple">
<li>When negative: edge <cite>(source, target)</cite> does not exist, therefore it&#8217;s not part of the graph.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><strong>reverse_cost</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-NUMERICAL</span></tt></td>
<td>-1</td>
<td><p class="first">Weight of the edge <cite>(target, source)</cite>,</p>
<ul class="last simple">
<li>When negative: edge <cite>(target, source)</cite> does not exist, therefore it&#8217;s not part of the graph.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Where:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">ANY-INTEGER:</th><td class="field-body">SMALLINT, INTEGER, BIGINT</td>
</tr>
<tr class="field-even field"><th class="field-name">ANY-NUMERICAL:</th><td class="field-body">SMALLINT, INTEGER, BIGINT, REAL, FLOAT</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="description-of-the-edges-sql-query-for-astar-like-functions">
<h3>Description of the edges_sql query for astar like functions<a class="headerlink" href="#description-of-the-edges-sql-query-for-astar-like-functions" title="Permalink to this headline">¶</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">edges_sql:</th><td class="field-body">an SQL query, which should return a set of rows with the following columns:</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="14%" />
<col width="6%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>id</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td>Identifier of the edge.</td>
</tr>
<tr class="row-odd"><td><strong>source</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td>Identifier of the first end point vertex of the edge.</td>
</tr>
<tr class="row-even"><td><strong>target</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td>Identifier of the second end point vertex of the edge.</td>
</tr>
<tr class="row-odd"><td><strong>cost</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-NUMERICAL</span></tt></td>
<td>&nbsp;</td>
<td><p class="first">Weight of the edge  <cite>(source, target)</cite></p>
<ul class="last simple">
<li>When negative: edge <cite>(source, target)</cite> does not exist, therefore it&#8217;s not part of the graph.</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><strong>reverse_cost</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-NUMERICAL</span></tt></td>
<td>-1</td>
<td><p class="first">Weight of the edge <cite>(target, source)</cite>,</p>
<ul class="last simple">
<li>When negative: edge <cite>(target, source)</cite> does not exist, therefore it&#8217;s not part of the graph.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><strong>x1</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-NUMERICAL</span></tt></td>
<td>&nbsp;</td>
<td>X coordinate of <cite>source</cite> vertex.</td>
</tr>
<tr class="row-even"><td><strong>y1</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-NUMERICAL</span></tt></td>
<td>&nbsp;</td>
<td>Y coordinate of <cite>source</cite> vertex.</td>
</tr>
<tr class="row-odd"><td><strong>x2</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-NUMERICAL</span></tt></td>
<td>&nbsp;</td>
<td>X coordinate of <cite>target</cite> vertex.</td>
</tr>
<tr class="row-even"><td><strong>y2</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-NUMERICAL</span></tt></td>
<td>&nbsp;</td>
<td>Y coordinate of <cite>target</cite> vertex.</td>
</tr>
</tbody>
</table>
<p>Where:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">ANY-INTEGER:</th><td class="field-body">SMALLINT, INTEGER, BIGINT</td>
</tr>
<tr class="field-even field"><th class="field-name">ANY-NUMERICAL:</th><td class="field-body">SMALLINT, INTEGER, BIGINT, REAL, FLOAT</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="description-of-the-edges-sql-query-for-max-flow-like-functions">
<h3>Description of the edges_sql query for Max-flow like functions<a class="headerlink" href="#description-of-the-edges-sql-query-for-max-flow-like-functions" title="Permalink to this headline">¶</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">edges_sql:</th><td class="field-body">an SQL query, which should return a set of rows with the following columns:</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="13%" />
<col width="6%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>id</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td>Identifier of the edge.</td>
</tr>
<tr class="row-odd"><td><strong>source</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td>Identifier of the first end point vertex of the edge.</td>
</tr>
<tr class="row-even"><td><strong>target</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td>Identifier of the second end point vertex of the edge.</td>
</tr>
<tr class="row-odd"><td><strong>capacity</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>&nbsp;</td>
<td><p class="first">Weight of the edge  <cite>(source, target)</cite></p>
<ul class="last simple">
<li>When negative: edge <cite>(source, target)</cite> does not exist, therefore it&#8217;s not part of the graph.</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><strong>reverse_capacity</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>-1</td>
<td><p class="first">Weight of the edge <cite>(target, source)</cite>,</p>
<ul class="last simple">
<li>When negative: edge <cite>(target, source)</cite> does not exist, therefore it&#8217;s not part of the graph.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Where:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">ANY-INTEGER:</th><td class="field-body">SMALLINT, INTEGER, BIGINT</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="description-of-the-points-sql-query">
<h3>Description of the Points SQL query<a class="headerlink" href="#description-of-the-points-sql-query" title="Permalink to this headline">¶</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">points_sql:</th><td class="field-body">an SQL query, which should return a set of rows with the following columns:</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="14%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>pid</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td><p class="first">(optional) Identifier of the point.</p>
<ul class="last simple">
<li>If column present, it can not be NULL.</li>
<li>If column not present, a sequential identifier will be given automatically.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><strong>edge_id</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-INTEGER</span></tt></td>
<td>Identifier of the &#8220;closest&#8221; edge to the point.</td>
</tr>
<tr class="row-even"><td><strong>fraction</strong></td>
<td><tt class="docutils literal"><span class="pre">ANY-NUMERICAL</span></tt></td>
<td>Value in &lt;0,1&gt; that indicates the relative postition from the first end point of the edge.</td>
</tr>
<tr class="row-odd"><td><strong>side</strong></td>
<td><tt class="docutils literal"><span class="pre">CHAR</span></tt></td>
<td><p class="first">(optional) Value in [&#8216;b&#8217;, &#8216;r&#8217;, &#8216;l&#8217;, NULL] indicating if the point is:</p>
<ul class="last simple">
<li>In the right, left of the edge or</li>
<li>If it doesn&#8217;t matter with &#8216;b&#8217; or NULL.</li>
<li>If column not present &#8216;b&#8217; is considered.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Where:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">ANY-INTEGER:</th><td class="field-body">smallint, int, bigint</td>
</tr>
<tr class="field-even field"><th class="field-name">ANY-NUMERICAL:</th><td class="field-body">smallint, int, bigint, real, float</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="return-columns-values">
<span id="return-values"></span><h2>Return columns &amp; values<a class="headerlink" href="#return-columns-values" title="Permalink to this headline">¶</a></h2>
<p>There are several kinds of columns returned are depending of the function.</p>
<div class="section" id="description-of-the-return-values-for-a-path">
<h3>Description of the return values for a path<a class="headerlink" href="#description-of-the-return-values-for-a-path" title="Permalink to this headline">¶</a></h3>
<p>Returns set of <tt class="docutils literal"><span class="pre">(seq,</span> <span class="pre">path_seq</span> <span class="pre">[,</span> <span class="pre">start_vid]</span> <span class="pre">[,</span> <span class="pre">end_vid],</span> <span class="pre">node,</span> <span class="pre">edge,</span> <span class="pre">cost,</span> <span class="pre">agg_cost)</span></tt></p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="6%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>seq</strong></td>
<td><tt class="docutils literal"><span class="pre">INT</span></tt></td>
<td>Sequential value starting from <strong>1</strong>.</td>
</tr>
<tr class="row-odd"><td><strong>path_id</strong></td>
<td><tt class="docutils literal"><span class="pre">INT</span></tt></td>
<td>Path identifier. Has value <strong>1</strong> for the first of a path. Used when there are multiple paths for the same <tt class="docutils literal"><span class="pre">start_vid</span></tt> to <tt class="docutils literal"><span class="pre">end_vid</span></tt> combination.</td>
</tr>
<tr class="row-even"><td><strong>path_seq</strong></td>
<td><tt class="docutils literal"><span class="pre">INT</span></tt></td>
<td>Relative position in the path. Has value <strong>1</strong> for the beginning of a path.</td>
</tr>
<tr class="row-odd"><td><strong>start_vid</strong></td>
<td><tt class="docutils literal"><span class="pre">BIGINT</span></tt></td>
<td>Identifier of the starting vertex. Used when multiple starting vetrices are in the query.</td>
</tr>
<tr class="row-even"><td><strong>end_vid</strong></td>
<td><tt class="docutils literal"><span class="pre">BIGINT</span></tt></td>
<td>Identifier of the ending vertex. Used when multiple ending vertices are in the query.</td>
</tr>
<tr class="row-odd"><td><strong>node</strong></td>
<td><tt class="docutils literal"><span class="pre">BIGINT</span></tt></td>
<td>Identifier of the node in the path from <tt class="docutils literal"><span class="pre">start_vid</span></tt> to <tt class="docutils literal"><span class="pre">end_vid</span></tt>.</td>
</tr>
<tr class="row-even"><td><strong>edge</strong></td>
<td><tt class="docutils literal"><span class="pre">BIGINT</span></tt></td>
<td>Identifier of the edge used to go from <tt class="docutils literal"><span class="pre">node</span></tt> to the next node in the path sequence. <tt class="docutils literal"><span class="pre">-1</span></tt> for the last node of the path.</td>
</tr>
<tr class="row-odd"><td><strong>cost</strong></td>
<td><tt class="docutils literal"><span class="pre">FLOAT</span></tt></td>
<td>Cost to traverse from <tt class="docutils literal"><span class="pre">node</span></tt> using <tt class="docutils literal"><span class="pre">edge</span></tt> to the next node in the path sequence.</td>
</tr>
<tr class="row-even"><td><strong>agg_cost</strong></td>
<td><tt class="docutils literal"><span class="pre">FLOAT</span></tt></td>
<td>Aggregate cost from <tt class="docutils literal"><span class="pre">start_v</span></tt> to <tt class="docutils literal"><span class="pre">node</span></tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="description-of-the-return-values-for-a-cost-function">
<h3>Description of the return values for a Cost function<a class="headerlink" href="#description-of-the-return-values-for-a-cost-function" title="Permalink to this headline">¶</a></h3>
<p>Returns set of <tt class="docutils literal"><span class="pre">(start_vid,</span> <span class="pre">end_vid,</span> <span class="pre">agg_cost)</span></tt></p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="9%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>start_vid</strong></td>
<td><tt class="docutils literal"><span class="pre">BIGINT</span></tt></td>
<td>Identifier of the starting vertex. Used when multiple starting vetrices are in the query.</td>
</tr>
<tr class="row-odd"><td><strong>end_vid</strong></td>
<td><tt class="docutils literal"><span class="pre">BIGINT</span></tt></td>
<td>Identifier of the ending vertex. Used when multiple ending vertices are in the query.</td>
</tr>
<tr class="row-even"><td><strong>agg_cost</strong></td>
<td><tt class="docutils literal"><span class="pre">FLOAT</span></tt></td>
<td>Aggregate cost from <tt class="docutils literal"><span class="pre">start_vid</span></tt> to <tt class="docutils literal"><span class="pre">end_vid</span></tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="description-of-the-return-values">
<h3>Description of the Return Values<a class="headerlink" href="#description-of-the-return-values" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="19%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>seq</strong></td>
<td><tt class="docutils literal"><span class="pre">INT</span></tt></td>
<td>Sequential value starting from <strong>1</strong>.</td>
</tr>
<tr class="row-odd"><td><strong>edge_id</strong></td>
<td><tt class="docutils literal"><span class="pre">BIGINT</span></tt></td>
<td>Identifier of the edge in the original query(edges_sql).</td>
</tr>
<tr class="row-even"><td><strong>source</strong></td>
<td><tt class="docutils literal"><span class="pre">BIGINT</span></tt></td>
<td>Identifier of the first end point vertex of the edge.</td>
</tr>
<tr class="row-odd"><td><strong>target</strong></td>
<td><tt class="docutils literal"><span class="pre">BIGINT</span></tt></td>
<td>Identifier of the second end point vertex of the edge.</td>
</tr>
<tr class="row-even"><td><strong>flow</strong></td>
<td><tt class="docutils literal"><span class="pre">BIGINT</span></tt></td>
<td>Flow through the edge in the direction (source, target).</td>
</tr>
<tr class="row-odd"><td><strong>residual_capacity</strong></td>
<td><tt class="docutils literal"><span class="pre">BIGINT</span></tt></td>
<td>Residual capacity of the edge in the direction (source, target).</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="advanced-topics">
<span id="id5"></span><h2>Advanced Topics<a class="headerlink" href="#advanced-topics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="routing-topology">
<span id="topology"></span><h3>Routing Topology<a class="headerlink" href="#routing-topology" title="Permalink to this headline">¶</a></h3>
<p class="rubric">Overview</p>
<p>Typically when GIS files are loaded into the data database for use with pgRouting they do not have topology information associated with them. To create a useful topology the data needs to be &#8220;noded&#8221;. This means that where two or more roads form an intersection there it needs to be a node at the intersection and all the road segments need to be broken at the intersection, assuming that you can navigate from any of these segments to any other segment via that intersection.</p>
<p>You can use the <a class="reference internal" href="#analytics"><em>graph analysis functions</em></a> to help you see where you might have topology problems in your data. If you need to node your data, we also have a function <a class="reference internal" href="pgr_nodeNetwork.html#pgr-node-network"><em>pgr_nodeNetwork()</em></a> that might work for you. This function splits ALL crossing segments and nodes them. There are some cases where this might NOT be the right thing to do.</p>
<p>For example, when you have an overpass and underpass intersection, you do not want these noded, but pgr_nodeNetwork does not know that is the case and will node them which is not good because then the router will be able to turn off the overpass onto the underpass like it was a flat 2D intersection. To deal with this problem some data sets use z-levels at these types of intersections and other data might not node these intersection which would be ok.</p>
<p>For those cases where topology needs to be added the following functions may be useful. One way to prep the data for pgRouting is to add the following columns to your table and then populate them as appropriate. This example makes a lot of assumption like that you original data tables already has certain columns in it like <tt class="docutils literal"><span class="pre">one_way</span></tt>, <tt class="docutils literal"><span class="pre">fcc</span></tt>, and possibly others and that they contain specific data values. This is only to give you an idea of what you can do with your data.</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">edge_table</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="k">source</span> <span class="nb">integer</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">target</span> <span class="nb">integer</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">cost_len</span> <span class="n">double</span> <span class="k">precision</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">cost_time</span> <span class="n">double</span> <span class="k">precision</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">rcost_len</span> <span class="n">double</span> <span class="k">precision</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">rcost_time</span> <span class="n">double</span> <span class="k">precision</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">x1</span> <span class="n">double</span> <span class="k">precision</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">y1</span> <span class="n">double</span> <span class="k">precision</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">x2</span> <span class="n">double</span> <span class="k">precision</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">y2</span> <span class="n">double</span> <span class="k">precision</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">to_cost</span> <span class="n">double</span> <span class="k">precision</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="k">rule</span> <span class="nb">text</span><span class="p">,</span>
    <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">isolated</span> <span class="nb">integer</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">pgr_createTopology</span><span class="p">(</span><span class="s1">&#39;edge_table&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">000001</span><span class="p">,</span> <span class="s1">&#39;the_geom&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="pgr_createTopology.html#pgr-create-topology"><em>pgr_createTopology()</em></a> will create the <tt class="docutils literal"><span class="pre">vertices_tmp</span></tt> table and populate the <tt class="docutils literal"><span class="pre">source</span></tt> and <tt class="docutils literal"><span class="pre">target</span></tt> columns. The following example populated the remaining columns. In this example, the <tt class="docutils literal"><span class="pre">fcc</span></tt> column contains feature class code and the <tt class="docutils literal"><span class="pre">CASE</span></tt> statements converts it to an average speed.</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">UPDATE</span> <span class="n">edge_table</span> <span class="k">SET</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">st_x</span><span class="p">(</span><span class="n">st_startpoint</span><span class="p">(</span><span class="n">the_geom</span><span class="p">)),</span>
                      <span class="n">y1</span> <span class="o">=</span> <span class="n">st_y</span><span class="p">(</span><span class="n">st_startpoint</span><span class="p">(</span><span class="n">the_geom</span><span class="p">)),</span>
                      <span class="n">x2</span> <span class="o">=</span> <span class="n">st_x</span><span class="p">(</span><span class="n">st_endpoint</span><span class="p">(</span><span class="n">the_geom</span><span class="p">)),</span>
                      <span class="n">y2</span> <span class="o">=</span> <span class="n">st_y</span><span class="p">(</span><span class="n">st_endpoint</span><span class="p">(</span><span class="n">the_geom</span><span class="p">)),</span>
  <span class="n">cost_len</span>  <span class="o">=</span> <span class="n">st_length_spheroid</span><span class="p">(</span><span class="n">the_geom</span><span class="p">,</span> <span class="s1">&#39;SPHEROID[&quot;WGS84&quot;,6378137,298.25728]&#39;</span><span class="p">),</span>
  <span class="n">rcost_len</span> <span class="o">=</span> <span class="n">st_length_spheroid</span><span class="p">(</span><span class="n">the_geom</span><span class="p">,</span> <span class="s1">&#39;SPHEROID[&quot;WGS84&quot;,6378137,298.25728]&#39;</span><span class="p">),</span>
  <span class="n">len_km</span> <span class="o">=</span> <span class="n">st_length_spheroid</span><span class="p">(</span><span class="n">the_geom</span><span class="p">,</span> <span class="s1">&#39;SPHEROID[&quot;WGS84&quot;,6378137,298.25728]&#39;</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span>
  <span class="n">len_miles</span> <span class="o">=</span> <span class="n">st_length_spheroid</span><span class="p">(</span><span class="n">the_geom</span><span class="p">,</span> <span class="s1">&#39;SPHEROID[&quot;WGS84&quot;,6378137,298.25728]&#39;</span><span class="p">)</span>
              <span class="o">/</span> <span class="mi">1000</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">6213712</span><span class="p">,</span>
  <span class="n">speed_mph</span> <span class="o">=</span> <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A10&#39;</span> <span class="k">THEN</span> <span class="mi">65</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A15&#39;</span> <span class="k">THEN</span> <span class="mi">65</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A20&#39;</span> <span class="k">THEN</span> <span class="mi">55</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A25&#39;</span> <span class="k">THEN</span> <span class="mi">55</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A30&#39;</span> <span class="k">THEN</span> <span class="mi">45</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A35&#39;</span> <span class="k">THEN</span> <span class="mi">45</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A40&#39;</span> <span class="k">THEN</span> <span class="mi">35</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A45&#39;</span> <span class="k">THEN</span> <span class="mi">35</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A50&#39;</span> <span class="k">THEN</span> <span class="mi">25</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A60&#39;</span> <span class="k">THEN</span> <span class="mi">25</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A61&#39;</span> <span class="k">THEN</span> <span class="mi">25</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A62&#39;</span> <span class="k">THEN</span> <span class="mi">25</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A64&#39;</span> <span class="k">THEN</span> <span class="mi">25</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A70&#39;</span> <span class="k">THEN</span> <span class="mi">15</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A69&#39;</span> <span class="k">THEN</span> <span class="mi">10</span>
                   <span class="k">ELSE</span> <span class="k">null</span> <span class="k">END</span><span class="p">,</span>
  <span class="n">speed_kmh</span> <span class="o">=</span> <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A10&#39;</span> <span class="k">THEN</span> <span class="mi">104</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A15&#39;</span> <span class="k">THEN</span> <span class="mi">104</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A20&#39;</span> <span class="k">THEN</span> <span class="mi">88</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A25&#39;</span> <span class="k">THEN</span> <span class="mi">88</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A30&#39;</span> <span class="k">THEN</span> <span class="mi">72</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A35&#39;</span> <span class="k">THEN</span> <span class="mi">72</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A40&#39;</span> <span class="k">THEN</span> <span class="mi">56</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A45&#39;</span> <span class="k">THEN</span> <span class="mi">56</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A50&#39;</span> <span class="k">THEN</span> <span class="mi">40</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A60&#39;</span> <span class="k">THEN</span> <span class="mi">50</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A61&#39;</span> <span class="k">THEN</span> <span class="mi">40</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A62&#39;</span> <span class="k">THEN</span> <span class="mi">40</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A64&#39;</span> <span class="k">THEN</span> <span class="mi">40</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A70&#39;</span> <span class="k">THEN</span> <span class="mi">25</span>
                   <span class="k">WHEN</span> <span class="n">fcc</span><span class="o">=</span><span class="s1">&#39;A69&#39;</span> <span class="k">THEN</span> <span class="mi">15</span>
                   <span class="k">ELSE</span> <span class="k">null</span> <span class="k">END</span><span class="p">;</span>

<span class="c1">-- UPDATE the cost information based on oneway streets</span>

<span class="k">UPDATE</span> <span class="n">edge_table</span> <span class="k">SET</span>
    <span class="n">cost_time</span> <span class="o">=</span> <span class="k">CASE</span>
        <span class="k">WHEN</span> <span class="n">one_way</span><span class="o">=</span><span class="s1">&#39;TF&#39;</span> <span class="k">THEN</span> <span class="mi">10000</span><span class="p">.</span><span class="mi">0</span>
        <span class="k">ELSE</span> <span class="n">cost_len</span><span class="o">/</span><span class="mi">1000</span><span class="p">.</span><span class="mi">0</span><span class="o">/</span><span class="n">speed_kmh</span><span class="p">::</span><span class="nb">numeric</span><span class="o">*</span><span class="mi">3600</span><span class="p">.</span><span class="mi">0</span>
        <span class="k">END</span><span class="p">,</span>
    <span class="n">rcost_time</span> <span class="o">=</span> <span class="k">CASE</span>
        <span class="k">WHEN</span> <span class="n">one_way</span><span class="o">=</span><span class="s1">&#39;FT&#39;</span> <span class="k">THEN</span> <span class="mi">10000</span><span class="p">.</span><span class="mi">0</span>
        <span class="k">ELSE</span> <span class="n">cost_len</span><span class="o">/</span><span class="mi">1000</span><span class="p">.</span><span class="mi">0</span><span class="o">/</span><span class="n">speed_kmh</span><span class="p">::</span><span class="nb">numeric</span><span class="o">*</span><span class="mi">3600</span><span class="p">.</span><span class="mi">0</span>
        <span class="k">END</span><span class="p">;</span>

<span class="c1">-- clean up the database because we have updated a lot of records</span>

<span class="k">VACUUM</span> <span class="k">ANALYZE</span> <span class="k">VERBOSE</span> <span class="n">edge_table</span><span class="p">;</span>
</pre></div>
</div>
<p>Now your database should be ready to use any (most?) of the pgRouting algorithms.</p>
</div>
</div>
<div class="section" id="graph-analytics">
<span id="analytics"></span><h2>Graph Analytics<a class="headerlink" href="#graph-analytics" title="Permalink to this headline">¶</a></h2>
<p class="rubric">Overview</p>
<p>It is common to find problems with graphs that have not been constructed fully noded or in graphs with z-levels at intersection that have been entered incorrectly. An other problem is one way streets that have been entered in the wrong direction. We can not detect errors with respect to &#8220;ground&#8221; truth, but we can look for inconsistencies and some anomalies in a graph and report them for additional inspections.</p>
<p>We do not current have any visualization tools for these problems, but I have used mapserver to render the graph and highlight potential problem areas. Someone familiar with graphviz might contribute tools for generating images with that.</p>
<div class="section" id="analyze-a-graph">
<h3>Analyze a Graph<a class="headerlink" href="#analyze-a-graph" title="Permalink to this headline">¶</a></h3>
<p>With <a class="reference internal" href="pgr_analyzeGraph.html#pgr-analyze-graph"><em>pgr_analyzeGraph</em></a> the graph can be checked for errors. For example for table &#8220;mytab&#8221; that has &#8220;mytab_vertices_pgr&#8221; as the vertices table:</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="n">pgr_analyzeGraph</span><span class="p">(</span><span class="s1">&#39;mytab&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">000002</span><span class="p">);</span>
<span class="n">NOTICE</span><span class="p">:</span>  <span class="n">Performing</span> <span class="n">checks</span><span class="p">,</span> <span class="n">pelase</span> <span class="n">wait</span><span class="p">...</span>
<span class="n">NOTICE</span><span class="p">:</span>  <span class="n">Analyzing</span> <span class="k">for</span> <span class="n">dead</span> <span class="n">ends</span><span class="p">.</span> <span class="n">Please</span> <span class="n">wait</span><span class="p">...</span>
<span class="n">NOTICE</span><span class="p">:</span>  <span class="n">Analyzing</span> <span class="k">for</span> <span class="n">gaps</span><span class="p">.</span> <span class="n">Please</span> <span class="n">wait</span><span class="p">...</span>
<span class="n">NOTICE</span><span class="p">:</span>  <span class="n">Analyzing</span> <span class="k">for</span> <span class="n">isolated</span> <span class="n">edges</span><span class="p">.</span> <span class="n">Please</span> <span class="n">wait</span><span class="p">...</span>
<span class="n">NOTICE</span><span class="p">:</span>  <span class="n">Analyzing</span> <span class="k">for</span> <span class="n">ring</span> <span class="n">geometries</span><span class="p">.</span> <span class="n">Please</span> <span class="n">wait</span><span class="p">...</span>
<span class="n">NOTICE</span><span class="p">:</span>  <span class="n">Analyzing</span> <span class="k">for</span> <span class="n">intersections</span><span class="p">.</span> <span class="n">Please</span> <span class="n">wait</span><span class="p">...</span>
<span class="n">NOTICE</span><span class="p">:</span>              <span class="n">ANALYSIS</span> <span class="n">RESULTS</span> <span class="k">FOR</span> <span class="n">SELECTED</span> <span class="n">EDGES</span><span class="p">:</span>
<span class="n">NOTICE</span><span class="p">:</span>                    <span class="n">Isolated</span> <span class="n">segments</span><span class="p">:</span> <span class="mi">158</span>
<span class="n">NOTICE</span><span class="p">:</span>                            <span class="n">Dead</span> <span class="n">ends</span><span class="p">:</span> <span class="mi">20028</span>
<span class="n">NOTICE</span><span class="p">:</span>  <span class="n">Potential</span> <span class="n">gaps</span> <span class="k">found</span> <span class="n">near</span> <span class="n">dead</span> <span class="n">ends</span><span class="p">:</span> <span class="mi">527</span>
<span class="n">NOTICE</span><span class="p">:</span>               <span class="n">Intersections</span> <span class="n">detected</span><span class="p">:</span> <span class="mi">2560</span>
<span class="n">NOTICE</span><span class="p">:</span>                      <span class="n">Ring</span> <span class="n">geometries</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">pgr_analyzeGraph</span>
<span class="c1">----------</span>
   <span class="n">OK</span>
<span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>
</pre></div>
</div>
<p>In the vertices table &#8220;mytab_vertices_pgr&#8221;:</p>
<blockquote>
<div><ul class="simple">
<li>Deadends are identified by <tt class="docutils literal"><span class="pre">cnt=1</span></tt></li>
<li>Potencial gap problems are identified with <tt class="docutils literal"><span class="pre">chk=1</span></tt>.</li>
</ul>
</div></blockquote>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">as</span> <span class="n">deadends</span>  <span class="k">FROM</span> <span class="n">mytab_vertices_pgr</span> <span class="k">WHERE</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">deadends</span>
<span class="c1">----------</span>
    <span class="mi">20028</span>
 <span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>

<span class="k">SELECT</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">as</span> <span class="n">gaps</span>  <span class="k">FROM</span> <span class="n">mytab_vertices_pgr</span> <span class="k">WHERE</span> <span class="n">chk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="n">gaps</span>
 <span class="c1">-----</span>
   <span class="mi">527</span>
 <span class="p">(</span><span class="mi">1</span> <span class="k">row</span><span class="p">)</span>
</pre></div>
</div>
<p>For isolated road segments, for example, a segment where both ends are deadends. you can find these with the following query:</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="o">*</span>
    <span class="k">FROM</span> <span class="n">mytab</span> <span class="n">a</span><span class="p">,</span> <span class="n">mytab_vertices_pgr</span> <span class="n">b</span><span class="p">,</span> <span class="n">mytab_vertices_pgr</span> <span class="k">c</span>
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="k">source</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">cnt</span><span class="o">=</span><span class="mi">1</span> <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">target</span><span class="o">=</span><span class="k">c</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="k">c</span><span class="p">.</span><span class="n">cnt</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>If you want to visualize these on a graphic image, then you can use something like mapserver to render the edges and the vertices and style based on <tt class="docutils literal"><span class="pre">cnt</span></tt> or if they are isolated, etc. You can also do this with a tool like graphviz, or geoserver or other similar tools.</p>
</div>
<div class="section" id="analyze-one-way-streets">
<h3>Analyze One Way Streets<a class="headerlink" href="#analyze-one-way-streets" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="pgr_analyzeOneWay.html#pgr-analyze-oneway"><em>pgr_analyzeOneway</em></a> analyzes one way streets in a graph and identifies any flipped segments. Basically if you count the edges coming into a node and the edges exiting a node the number has to be greater than one.</p>
<p>This query will add two columns to the vertices_tmp table <tt class="docutils literal"><span class="pre">ein</span> <span class="pre">int</span></tt> and <tt class="docutils literal"><span class="pre">eout</span> <span class="pre">int</span></tt> and populate it with the appropriate counts. After running this on a graph you can identify nodes with potential problems with the following query.</p>
<p>The rules are defined as an array of text strings that if match the <tt class="docutils literal"><span class="pre">col</span></tt> value would be counted as true for the source or target in or out condition.</p>
</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>Lets assume we have a table &#8220;st&#8221; of edges and a column &#8220;one_way&#8221; that might have values like:</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;FT&#8217;    - oneway from the source to the target node.</li>
<li>&#8216;TF&#8217;    - oneway from the target to the source node.</li>
<li>&#8216;B&#8217;     - two way street.</li>
<li>&#8216;&#8217;      - empty field, assume twoway.</li>
<li>&lt;NULL&gt;  - NULL field, use two_way_if_null flag.</li>
</ul>
</div></blockquote>
<p>Then we could form the following query to analyze the oneway streets for errors.</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="n">pgr_analyzeOneway</span><span class="p">(</span><span class="s1">&#39;mytab&#39;</span><span class="p">,</span>
            <span class="nb">ARRAY</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;TF&#39;</span><span class="p">],</span>
            <span class="nb">ARRAY</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;FT&#39;</span><span class="p">],</span>
            <span class="nb">ARRAY</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;FT&#39;</span><span class="p">],</span>
            <span class="nb">ARRAY</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;TF&#39;</span><span class="p">],</span>
            <span class="p">);</span>

<span class="c1">-- now we can see the problem nodes</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">mytab_vertices_pgr</span> <span class="k">WHERE</span> <span class="n">ein</span><span class="o">=</span><span class="mi">0</span> <span class="k">OR</span> <span class="n">eout</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">-- and the problem edges connected to those nodes</span>
<span class="k">SELECT</span> <span class="n">gid</span> <span class="k">FROM</span> <span class="n">mytab</span> <span class="n">a</span><span class="p">,</span> <span class="n">mytab_vertices_pgr</span> <span class="n">b</span> <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="k">source</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">ein</span><span class="o">=</span><span class="mi">0</span> <span class="k">OR</span> <span class="n">eout</span><span class="o">=</span><span class="mi">0</span>
<span class="k">UNION</span>
<span class="k">SELECT</span> <span class="n">gid</span> <span class="k">FROM</span> <span class="n">mytab</span> <span class="n">a</span><span class="p">,</span> <span class="n">mytab_vertices_pgr</span> <span class="n">b</span> <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">target</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">ein</span><span class="o">=</span><span class="mi">0</span> <span class="k">OR</span> <span class="n">eout</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Typically these problems are generated by a break in the network, the one way direction set wrong, maybe an error related to z-levels or a network that is not properly noded.</p>
<p>The above tools do not detect all network issues, but they will identify some common problems. There are other problems that are hard to detect because they are more global in nature like multiple disconnected networks. Think of an island with a road network that is not connected to the mainland network because the bridge or ferry routes are missing.</p>
</div>
</div>
<div class="section" id="performance-tips">
<span id="performance"></span><h2>Performance Tips<a class="headerlink" href="#performance-tips" title="Permalink to this headline">¶</a></h2>
<div class="section" id="for-the-routing-functions">
<h3>For the Routing functions<a class="headerlink" href="#for-the-routing-functions" title="Permalink to this headline">¶</a></h3>
<p>To get faster results bound your queries to the area of interest of routing to have, for example, no more than one million rows.</p>
<p>Use an inner query SQL that does not include some edges in the routing function</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="k">source</span><span class="p">,</span> <span class="n">target</span> <span class="k">from</span> <span class="n">edge_table</span> <span class="k">WHERE</span>
        <span class="n">id</span> <span class="o">&lt;</span> <span class="mi">17</span> <span class="k">and</span>
        <span class="n">the_geom</span>  <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">select</span> <span class="n">st_buffer</span><span class="p">(</span><span class="n">the_geom</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">myarea</span> <span class="k">FROM</span>  <span class="n">edge_table</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Integrating the inner query to the pgRouting function:</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">pgr_dijkstra</span><span class="p">(</span>
        <span class="s1">&#39;SELECT id, source, target from edge_table WHERE</span>
<span class="s1">            id &lt; 17 and</span>
<span class="s1">            the_geom  &amp;&amp; (select st_buffer(the_geom,1) as myarea FROM  edge_table where id = 5)&#39;</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="for-the-topology-functions">
<h3>For the topology functions:<a class="headerlink" href="#for-the-topology-functions" title="Permalink to this headline">¶</a></h3>
<p>When &#8220;you know&#8221; that you are going to remove a set of edges from the edges table, and without those edges you are going to use a routing function you can do the following:</p>
<p>Analize the new topology based on the actual topology:</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="n">pgr_analyzegraph</span><span class="p">(</span><span class="s1">&#39;edge_table&#39;</span><span class="p">,</span><span class="n">rows_where</span><span class="p">:</span><span class="o">=</span><span class="s1">&#39;id &lt; 17&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Or create a new topology if the change is permanent:</p>
<div class="highlight-sql"><div class="highlight"><pre><span class="n">pgr_createTopology</span><span class="p">(</span><span class="s1">&#39;edge_table&#39;</span><span class="p">,</span><span class="n">rows_where</span><span class="p">:</span><span class="o">=</span><span class="s1">&#39;id &lt; 17&#39;</span><span class="p">);</span>
<span class="n">pgr_analyzegraph</span><span class="p">(</span><span class="s1">&#39;edge_table&#39;</span><span class="p">,</span><span class="n">rows_where</span><span class="p">:</span><span class="o">=</span><span class="s1">&#39;id &lt; 17&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="how-to-contribute">
<span id="how-contribute"></span><h2>How to contribute<a class="headerlink" href="#how-to-contribute" title="Permalink to this headline">¶</a></h2>
<p class="rubric">Wiki</p>
<ul class="simple">
<li>Edit an existing  <a class="reference external" href="https://github.com/pgRouting/pgrouting/wiki">pgRouting Wiki</a> page.</li>
<li>Or create a new Wiki page<ul>
<li>Create a page on the <a class="reference external" href="https://github.com/pgRouting/pgrouting/wiki">pgRouting Wiki</a></li>
<li>Give the title an appropriate name</li>
</ul>
</li>
<li><a class="reference external" href="https://github.com/pgRouting/pgrouting/wiki/How-to:-Handle-parallel-edges-(KSP)">Example</a></li>
</ul>
<p class="rubric">Adding Functionaity to pgRouting</p>
<p>Consult the <a class="reference external" href="http://docs.pgrouting.org/doxy/2.4/index.html">developer&#8217;s documentation</a></p>
<p class="rubric">Indices and tables</p>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="sampledata.html">Sample Data</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="pgr_version.html">pgr_version</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright pgRouting Contributors - Version v2.4.0.
      Last updated on Mar 20, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>